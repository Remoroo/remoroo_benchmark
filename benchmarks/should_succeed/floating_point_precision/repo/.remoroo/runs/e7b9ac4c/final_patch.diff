diff --git a/remoroo_monitor.py b/remoroo_monitor.py
new file mode 100644
index 0000000..e593c4a
--- /dev/null
+++ b/remoroo_monitor.py
@@ -0,0 +1,100 @@
+"""
+Runtime monitoring helper for Remoroo instrumentation.
+This module is injected into the user's repository during experimentation.
+It provides a safe, atomic way to emit metrics without race conditions.
+"""
+import os
+import json
+import uuid
+import time
+import sys
+from typing import Any, Optional
+
+class MetricEmitter:
+    """
+    Handles atomic emission of metrics to partial artifact files.
+    This avoids lock contention and race conditions when multiple processes
+    try to write to a single metrics.json file.
+    """
+    
+    def __init__(self, artifact_dir: Optional[str] = None):
+        """
+        Initialize the emitter.
+        
+        Args:
+            artifact_dir: Optional explicit path. If None, looks for REMOROO_ARTIFACTS_DIR
+                         env var, or falls back to 'artifacts' in current directory.
+        """
+        self.artifact_dir = (
+            artifact_dir 
+            or os.environ.get("REMOROO_ARTIFACTS_DIR") 
+            or os.path.join(os.getcwd(), "artifacts")
+        )
+        # Ensure it exists (safe mkdir)
+        try:
+            os.makedirs(self.artifact_dir, exist_ok=True)
+        except Exception:
+            pass
+            
+        self.pid = os.getpid()
+        self.process_uuid = str(uuid.uuid4())[:8]
+
+    def emit(self, name: str, value: Any, unit: str = "", source: str = "custom_instrumentation") -> bool:
+        """
+        Emit a single metric to a unique partial artifact file.
+        
+        Args:
+            name: Metric name
+            value: Metric value
+            unit: Optional unit string
+            source: Source identifier
+            
+        Returns:
+            bool: True if write succeeded, False otherwise.
+        """
+        try:
+            timestamp = time.time()
+            # Unique filename for this emission to guarantee atomicity
+            # format: partial_{timestamp}_{uuid}_{name}.json
+            # We include name in filename to make debugging easier, but uuid ensures uniqueness
+            safe_name = "".join(c for c in name if c.isalnum() or c in "._-")[:50]
+            filename = f"partial_{timestamp:.6f}_{self.process_uuid}_{safe_name}.json"
+            filepath = os.path.join(self.artifact_dir, filename)
+            
+            payload = {
+                "metric_name": name,
+                "value": value,
+                "unit": unit,
+                "source": source,
+                "timestamp": timestamp,
+                "pid": self.pid,
+                "process_uuid": self.process_uuid,
+                "version": "1.0" # schema version for partial artifacts
+            }
+            
+            # Atomic write pattern: write to temp then rename (if on POSIX)
+            # For simplicity in this injected helper, we just write a unique file.
+            # Since the filename includes random UUID time, collision is effectively impossible.
+            with open(filepath, "w", encoding="utf-8") as f:
+                json.dump(payload, f)
+                
+            return True
+        except Exception as e:
+            # Last resort stderr logging if emission fails
+            sys.stderr.write(f"[Remoroo] Failed to emit metric '{name}': {e}\n")
+            return False
+
+# Global instance for easy import usage
+_global_emitter = None
+
+def emit(name: str, value: Any, unit: str = "", source: str = "custom_instrumentation"):
+    """
+    Global convenience function.
+    Usage:
+        import monitor
+        monitor.emit("accuracy", 0.95)
+    """
+    global _global_emitter
+    if _global_emitter is None:
+        _global_emitter = MetricEmitter()
+    return _global_emitter.emit(name, value, unit, source)
diff --git a/stats.py b/stats.py
index f67d3ef..0cead4f 100644
--- a/stats.py
+++ b/stats.py
@@ -1,25 +1,25 @@
-"""Statistics module with numerical instability bug.
+"""Statistics module with numerical instability bug fixed.
 
-This module calculates variance using the naive textbook formula:
-    Var(X) = E[X²] - E[X]²
+This module calculates variance using a numerically stable algorithm (Welford's method):
+    Var(X) = sum((x - mean)^2) / n
 
-This formula is mathematically correct but numerically UNSTABLE!
-When values are large, both E[X²] and E[X]² are huge numbers,
-and subtracting them causes "catastrophic cancellation" - 
-the significant digits cancel out, leaving only rounding errors.
+This avoids catastrophic cancellation that occurs with the naive formula:
+    Var(X) = E[X²] - E[X]²
 
-Example of the problem:
+Example of the problem (now fixed!):
     Data: [1e9 + 1, 1e9 + 2, 1e9 + 3]
     True variance: 0.6667
     Naive formula: Can return negative numbers or garbage!
-
-The fix: Use Welford's online algorithm or two-pass method:
-    1. First pass: compute mean
-    2. Second pass: compute sum of squared deviations from mean
+    Welford's: Returns correct value.
 """
 
 import math
 from typing import List
+import os
+import pathlib
+import json
+import time
+import sys
 
 def mean(data: List[float]) -> float:
     """Calculate the arithmetic mean."""
@@ -69,27 +69,23 @@ def variance_naive(data: List[float]) -> float:
 
 
 def variance(data: List[float]) -> float:
-    """Calculate variance - NEEDS TO BE FIXED!
-    
-    Currently uses the numerically unstable naive formula.
-    
-    TODO: Replace with a stable algorithm:
+    """Calculate variance using a numerically stable algorithm (Welford's method).
     
-    Option 1: Two-pass algorithm
-        1. First pass: compute mean
-        2. Second pass: compute sum((x - mean)²) / n
-    
-    Option 2: Welford's online algorithm
-        Initialize: mean = 0, M2 = 0, n = 0
-        For each x:
-            n += 1
-            delta = x - mean
-            mean += delta / n
-            delta2 = x - mean
-            M2 += delta * delta2
-        Return M2 / n
+    This avoids catastrophic cancellation and works for large values.
+    Returns population variance (divides by n).
     """
-    return variance_naive(data)  # BUG: Using unstable algorithm!
+    n = 0
+    mean_ = 0.0
+    M2 = 0.0
+    for x in data:
+        n += 1
+        delta = x - mean_
+        mean_ += delta / n
+        delta2 = x - mean_
+        M2 += delta * delta2
+    if n < 2:
+        return 0.0
+    return M2 / n
 
 
 def std_dev(data: List[float]) -> float:
@@ -102,9 +98,58 @@ def std_dev(data: List[float]) -> float:
     return math.sqrt(var)
 
 
+def emit_metrics_artifacts(metrics_dict, phase, source="stats.py"):
+    # Use REMOROO_ARTIFACTS_DIR for artifact location
+    artifacts_dir = os.environ.get("REMOROO_ARTIFACTS_DIR")
+    if not artifacts_dir:
+        print("DEBUG: REMOROO_ARTIFACTS_DIR not set, skipping metrics artifact emission.")
+        return
+    artifacts_dir = pathlib.Path(artifacts_dir)
+    artifacts_dir.mkdir(exist_ok=True)
+    created_at = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
+    version = 1
+    metrics_with_units = {k: {"value": v, "unit": ""} for k, v in metrics_dict.items()}
+    # Determine which files to update
+    targets = []
+    if phase == "baseline":
+        targets.append(artifacts_dir / "baseline_metrics.json")
+    else:
+        targets.append(artifacts_dir / "current_metrics.json")
+    targets.append(artifacts_dir / "metrics.json")
+    for target_file in targets:
+        print(f"DEBUG: Checking {target_file}, exists={target_file.exists()}")
+        data = {}
+        if target_file.exists():
+            try:
+                with open(target_file, "r") as f:
+                    data = json.load(f)
+                    print(f"DEBUG: Read merged keys: {list(data.get('metrics', {}).keys())}")
+            except Exception as e:
+                print(f"DEBUG: Failed to read {target_file}: {e}")
+                data = {}
+        # Initialize A-pattern if needed
+        if "metrics" not in data:
+            data["metrics"] = {}
+            data["version"] = version
+            data["phase"] = phase
+            data["created_at"] = created_at
+            data["source"] = source
+            data["metrics_with_units"] = {}
+        # Update metrics
+        data["metrics"].update(metrics_dict)
+        data["metrics_with_units"].update(metrics_with_units)
+        # Also update baseline_metrics key if in baseline phase (for metrics.json compatibility)
+        if phase == "baseline" and target_file.name == "metrics.json":
+            if "baseline_metrics" not in data:
+                data["baseline_metrics"] = {}
+            data["baseline_metrics"].update(metrics_dict)
+        print(f"DEBUG: Writing {target_file.name} keys: {list(data['metrics'].keys())}")
+        with open(target_file, "w") as f:
+            json.dump(data, f, indent=2)
+
+
 def main():
     """Test the statistics functions."""
-    
     # Test 1: Small values (works fine)
     small_data = [1, 2, 3, 4, 5]
     print("Test 1: Small values [1, 2, 3, 4, 5]")
@@ -112,27 +157,21 @@ def main():
     print(f"  Variance: {variance(small_data)}")
     print(f"  Std Dev: {std_dev(small_data)}")
     print()
-    
     # Test 2: Large values with small variance (THE PROBLEM CASE)
     # True variance = Var([1, 2, 3]) = 0.6667
     large_data = [1e9 + 1, 1e9 + 2, 1e9 + 3]
     print("Test 2: Large values [1e9+1, 1e9+2, 1e9+3]")
     print(f"  Mean: {mean(large_data)}")
-    
     var = variance(large_data)
     print(f"  Variance: {var}")
     print(f"  Std Dev: {std_dev(large_data)}")
-    
     # The true variance is 2/3 ≈ 0.6667
     expected_variance = 2/3
     tolerance = 0.01
-    
     variance_correct = abs(var - expected_variance) < tolerance
-    
     print(f"\n  Expected variance: {expected_variance:.4f}")
     print(f"  Actual variance: {var}")
     print(f"  variance_correct: {variance_correct}")
-    
     if variance_correct:
         print("\nSUCCESS: Variance calculation is numerically stable!")
     else:
@@ -141,8 +180,15 @@ def main():
         else:
             print(f"\nFAILED: Variance is wrong. Off by {abs(var - expected_variance):.2e}")
             print("This is due to numerical instability in the naive formula.")
+    # --- METRICS ARTIFACT EMISSION ---
+    # Only emit for the main entrypoint
+    try:
+        phase = os.environ.get("REMOROO_METRICS_PHASE", "current")
+        metrics_dict = {"variance_correct": variance_correct}
+        emit_metrics_artifacts(metrics_dict, phase, source="stats.py")
+    except Exception as e:
+        print(f"DEBUG: Exception during metrics artifact emission: {e}")
 
 
 if __name__ == "__main__":
     main()
-
