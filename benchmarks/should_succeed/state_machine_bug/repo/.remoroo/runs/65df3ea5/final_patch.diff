diff --git a/order_fsm.py b/order_fsm.py
index 38f58dc..bcd77d5 100644
--- a/order_fsm.py
+++ b/order_fsm.py
@@ -31,7 +31,11 @@ BUGS TO FIX:
 from enum import Enum, auto
 from typing import List, Optional, Dict, Any
 from dataclasses import dataclass, field
-
+import os
+import pathlib
+import json
+import time
+import sys
 
 class OrderState(Enum):
     PENDING = auto()
@@ -40,19 +44,16 @@ class OrderState(Enum):
     DELIVERED = auto()
     CANCELLED = auto()
 
-
 @dataclass
 class Order:
     order_id: str
     payment_received: bool = False
     items: List[str] = field(default_factory=list)
 
-
 class InvalidTransitionError(Exception):
     """Raised when an invalid state transition is attempted."""
     pass
 
-
 class OrderStateMachine:
     """State machine for order processing.
     
@@ -73,44 +74,52 @@ class OrderStateMachine:
         
         Returns True if transition succeeded, raises InvalidTransitionError if not.
         
-        BUGS:
-        1. Doesn't check if current state is terminal (CANCELLED/DELIVERED)
-        2. Doesn't validate payment for PENDING->PROCESSING
-        3. Allows invalid SHIPPED->CANCELLED
+        Fixes:
+        1. Prevents transitions from terminal states (CANCELLED/DELIVERED)
+        2. Validates payment for PENDING->PROCESSING
+        3. Disallows SHIPPED->CANCELLED
+        4. Prevents duplicate transitions (no-op)
         """
         old_state = self.state
-        
-        # BUG 1: Should check if current state is terminal!
-        # CANCELLED and DELIVERED are terminal states
-        
-        # Define valid transitions (but implementation is buggy!)
+
+        # 1. Prevent transitions from terminal states
+        if self.state in (OrderState.CANCELLED, OrderState.DELIVERED):
+            raise InvalidTransitionError(
+                f"Cannot transition from terminal state {self.state.name}")
+
+        # 4. Prevent duplicate transitions (no-op)
+        if new_state == self.state:
+            raise InvalidTransitionError(
+                f"Already in state {self.state.name}, duplicate transition not allowed")
+
+        # 3. Disallow SHIPPED->CANCELLED and CANCELLED->SHIPPED
+        # 2. Add payment guard for PENDING->PROCESSING
         valid_transitions = {
             OrderState.PENDING: [OrderState.PROCESSING, OrderState.CANCELLED],
             OrderState.PROCESSING: [OrderState.SHIPPED, OrderState.CANCELLED],
-            OrderState.SHIPPED: [OrderState.DELIVERED, OrderState.CANCELLED],  # BUG 3: CANCELLED shouldn't be here!
+            OrderState.SHIPPED: [OrderState.DELIVERED],  # CANCELLED removed
             OrderState.DELIVERED: [],  # Terminal
-            OrderState.CANCELLED: [OrderState.SHIPPED],  # BUG 1: Should be empty (terminal)!
+            OrderState.CANCELLED: [],  # Terminal
         }
-        
+
         # Check if transition is in valid list
         if new_state not in valid_transitions.get(self.state, []):
             raise InvalidTransitionError(
-                f"Cannot transition from {self.state.name} to {new_state.name}"
-            )
-        
-        # BUG 2: Should check payment_received for PENDING -> PROCESSING!
-        # Missing guard condition check here
-        
-        # BUG 4: Should check if we're already in this state
-        # (prevent no-op transitions that pollute history)
-        
+                f"Cannot transition from {self.state.name} to {new_state.name}")
+
+        # 2. Guard: payment required for PENDING->PROCESSING
+        if self.state == OrderState.PENDING and new_state == OrderState.PROCESSING:
+            if not self.order.payment_received:
+                raise InvalidTransitionError(
+                    "Payment required to process order (PENDING->PROCESSING)")
+
         # Perform transition
         self.state = new_state
         self.history.append({
             "from": old_state.name,
             "to": new_state.name,
         })
-        
+
         return True
     
     def process(self) -> bool:
@@ -137,7 +146,6 @@ class OrderStateMachine:
         """Get transition history."""
         return self.history.copy()
 
-
 def run_tests():
     """Run all state machine tests."""
     results = []
@@ -296,6 +304,45 @@ def run_tests():
     
     return results
 
+def emit_metrics_artifacts(metrics_dict, phase):
+    # Use REMOROO_ARTIFACTS_DIR for artifact location
+    artifacts_dir = pathlib.Path(os.environ["REMOROO_ARTIFACTS_DIR"])
+    artifacts_dir.mkdir(exist_ok=True)
+    targets = []
+    if phase == "baseline":
+        targets.append(artifacts_dir / "baseline_metrics.json")
+    else:
+        targets.append(artifacts_dir / "current_metrics.json")
+    targets.append(artifacts_dir / "metrics.json")
+    for target_file in targets:
+        print(f"DEBUG: Checking {target_file}, exists={target_file.exists()}")
+        data = {}
+        if target_file.exists():
+            try:
+                with open(target_file, "r") as f:
+                    data = json.load(f)
+                    print(f"DEBUG: Read merged keys: {list(data.get('metrics', {}).keys())}")
+            except Exception as e:
+                print(f"DEBUG: Failed to read {target_file}: {e}")
+                data = {}
+        # Initialize A-pattern if needed
+        if "metrics" not in data:
+            data["metrics"] = {}
+            data["version"] = 1
+            data["phase"] = phase
+            data["created_at"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
+        # Update metrics
+        for k, v in metrics_dict.items():
+            data["metrics"][k] = v
+        # Also update baseline_metrics key if in baseline phase (for metrics.json compatibility)
+        if phase == "baseline" and target_file.name == "metrics.json":
+            if "baseline_metrics" not in data:
+                data["baseline_metrics"] = {}
+            for k, v in metrics_dict.items():
+                data["baseline_metrics"][k] = v
+        print(f"DEBUG: Writing {target_file.name} keys: {list(data['metrics'].keys())}")
+        with open(target_file, "w") as f:
+            json.dump(data, f, indent=2)
 
 def main():
     """Run tests and report results."""
@@ -303,30 +350,29 @@ def main():
     print("ORDER STATE MACHINE TESTS")
     print("=" * 60)
     print()
-    
     results = run_tests()
-    
     print("\n" + "=" * 60)
     print("SUMMARY")
     print("=" * 60)
-    
     passed = sum(1 for _, success in results if success)
-    
     for name, success in results:
-        status = "✓ PASS" if success else "✗ FAIL"
+        status = "\u2713 PASS" if success else "\u2717 FAIL"
         print(f"  {status}: {name}")
-    
     all_tests_pass = (passed == len(results))
-    
     print(f"\nPassed: {passed}/{len(results)}")
     print(f"all_tests_pass: {all_tests_pass}")
-    
     if all_tests_pass:
         print("\nSUCCESS: All state machine bugs fixed!")
     else:
         print(f"\nFAILED: {len(results) - passed} test(s) failed")
-
+    # --- METRICS ARTIFACT EMISSION ---
+    try:
+        phase = os.environ.get("REMOROO_METRICS_PHASE", "current")
+        metrics = {"all_tests_pass": all_tests_pass}
+        emit_metrics_artifacts(metrics, phase)
+    except Exception as e:
+        print(f"DEBUG: Exception during metrics artifact emission: {e}")
+        raise
 
 if __name__ == "__main__":
     main()
-
diff --git a/remoroo_monitor.py b/remoroo_monitor.py
new file mode 100644
index 0000000..e593c4a
--- /dev/null
+++ b/remoroo_monitor.py
@@ -0,0 +1,100 @@
+"""
+Runtime monitoring helper for Remoroo instrumentation.
+This module is injected into the user's repository during experimentation.
+It provides a safe, atomic way to emit metrics without race conditions.
+"""
+import os
+import json
+import uuid
+import time
+import sys
+from typing import Any, Optional
+
+class MetricEmitter:
+    """
+    Handles atomic emission of metrics to partial artifact files.
+    This avoids lock contention and race conditions when multiple processes
+    try to write to a single metrics.json file.
+    """
+    
+    def __init__(self, artifact_dir: Optional[str] = None):
+        """
+        Initialize the emitter.
+        
+        Args:
+            artifact_dir: Optional explicit path. If None, looks for REMOROO_ARTIFACTS_DIR
+                         env var, or falls back to 'artifacts' in current directory.
+        """
+        self.artifact_dir = (
+            artifact_dir 
+            or os.environ.get("REMOROO_ARTIFACTS_DIR") 
+            or os.path.join(os.getcwd(), "artifacts")
+        )
+        # Ensure it exists (safe mkdir)
+        try:
+            os.makedirs(self.artifact_dir, exist_ok=True)
+        except Exception:
+            pass
+            
+        self.pid = os.getpid()
+        self.process_uuid = str(uuid.uuid4())[:8]
+
+    def emit(self, name: str, value: Any, unit: str = "", source: str = "custom_instrumentation") -> bool:
+        """
+        Emit a single metric to a unique partial artifact file.
+        
+        Args:
+            name: Metric name
+            value: Metric value
+            unit: Optional unit string
+            source: Source identifier
+            
+        Returns:
+            bool: True if write succeeded, False otherwise.
+        """
+        try:
+            timestamp = time.time()
+            # Unique filename for this emission to guarantee atomicity
+            # format: partial_{timestamp}_{uuid}_{name}.json
+            # We include name in filename to make debugging easier, but uuid ensures uniqueness
+            safe_name = "".join(c for c in name if c.isalnum() or c in "._-")[:50]
+            filename = f"partial_{timestamp:.6f}_{self.process_uuid}_{safe_name}.json"
+            filepath = os.path.join(self.artifact_dir, filename)
+            
+            payload = {
+                "metric_name": name,
+                "value": value,
+                "unit": unit,
+                "source": source,
+                "timestamp": timestamp,
+                "pid": self.pid,
+                "process_uuid": self.process_uuid,
+                "version": "1.0" # schema version for partial artifacts
+            }
+            
+            # Atomic write pattern: write to temp then rename (if on POSIX)
+            # For simplicity in this injected helper, we just write a unique file.
+            # Since the filename includes random UUID time, collision is effectively impossible.
+            with open(filepath, "w", encoding="utf-8") as f:
+                json.dump(payload, f)
+                
+            return True
+        except Exception as e:
+            # Last resort stderr logging if emission fails
+            sys.stderr.write(f"[Remoroo] Failed to emit metric '{name}': {e}\n")
+            return False
+
+# Global instance for easy import usage
+_global_emitter = None
+
+def emit(name: str, value: Any, unit: str = "", source: str = "custom_instrumentation"):
+    """
+    Global convenience function.
+    Usage:
+        import monitor
+        monitor.emit("accuracy", 0.95)
+    """
+    global _global_emitter
+    if _global_emitter is None:
+        _global_emitter = MetricEmitter()
+    return _global_emitter.emit(name, value, unit, source)
